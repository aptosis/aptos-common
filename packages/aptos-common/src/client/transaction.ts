import type {
  HexEncodedBytes,
  OnChainTransaction,
  TransactionSignature,
  Uint64,
} from "@aptosis/aptos-api";
import type { AptosAPI, AptosAPIResponse } from "@aptosis/aptos-client";
import { raiseForStatus } from "@aptosis/aptos-client";
import type {
  TransactionPayload,
  TransactionPayloadType,
  UserTransactionRequest,
} from "@aptosis/aptos-typed-api";
import type { MaybeHexString } from "@movingco/core";
import { Address, HexString } from "@movingco/core";

import type { Account } from "../account.js";
import { getAccount } from "./account.js";

/** Generates a transaction request that can be submitted to produce a raw transaction that
 * can be signed, which upon being signed can be submitted to the blockchain
 * @param sender Hex-encoded 16 bytes Aptos account address of transaction sender
 * @param payload Transaction payload. It depends on transaction type you want to send
 * @param options Options allow to overwrite default transaction options.
 * Defaults are:
 * ```bash
 *   {
 *     sender: senderAddress.hex(),
 *     sequence_number: account.sequence_number,
 *     max_gas_amount: "1000",
 *     gas_unit_price: "1",
 *     gas_currency_code: "XUS",
 *     // Unix timestamp, in seconds + 10 seconds
 *     expiration_timestamp_secs: (Math.floor(Date.now() / 1000) + 10).toString(),
 *   }
 * ```
 * @returns A transaction object
 */
export async function generateTransaction<
  TPayloadType extends TransactionPayloadType
>(
  api: AptosAPI,
  sender: MaybeHexString,
  payload: TransactionPayload<TPayloadType>,
  options: Partial<UserTransactionRequest<TPayloadType>> = {}
): Promise<UserTransactionRequest<TPayloadType>> {
  const senderAddress = Address.ensure(sender);
  const account = await getAccount(api, senderAddress.hex());
  return generateTransactionSync(
    senderAddress,
    account.sequence_number,
    payload,
    options
  );
}

/** Generates a transaction request that can be submitted to produce a raw transaction that
 * can be signed, which upon being signed can be submitted to the blockchain
 * @param sender Hex-encoded 16 bytes Aptos account address of transaction sender
 * @param payload Transaction payload. It depends on transaction type you want to send
 * @param options Options allow to overwrite default transaction options.
 * Defaults are:
 * ```bash
 *   {
 *     sender: senderAddress.hex(),
 *     sequence_number: account.sequence_number,
 *     max_gas_amount: "1000",
 *     gas_unit_price: "1",
 *     gas_currency_code: "XUS",
 *     // Unix timestamp, in seconds + 10 seconds
 *     expiration_timestamp_secs: (Math.floor(Date.now() / 1000) + 10).toString(),
 *   }
 * ```
 * @returns A transaction object
 */
export function generateTransactionSync<
  TPayloadType extends TransactionPayloadType
>(
  sender: MaybeHexString,
  sequenceNumber: Uint64,
  payload: TransactionPayload<TPayloadType>,
  options: Partial<UserTransactionRequest<TPayloadType>> = {}
): UserTransactionRequest<TPayloadType> {
  const senderAddress = Address.ensure(sender);
  return {
    sender: senderAddress.hex(),
    sequence_number: sequenceNumber,
    max_gas_amount: "1000",
    gas_unit_price: "1",
    gas_currency_code: "XUS",
    // Unix timestamp, in seconds + 10 seconds
    expiration_timestamp_secs: (Math.floor(Date.now() / 1000) + 10).toString(),
    payload,
    ...options,
  };
}

/**
 * Converts a transaction request by `generate_transaction` into it's binary hex BCS representation, ready for
 * signing and submitting.
 * Generally you may want to use `signTransaction`, as it takes care of this step + signing
 * @param txnRequest A raw transaction generated by `generateTransaction` method
 * @returns A hex-encoded string prefixed with `0x` and fulfilled with two hex digits per byte
 */
export async function createSigningMessage(
  api: AptosAPI,
  txnRequest: UserTransactionRequest
): Promise<HexEncodedBytes> {
  const response = (await api.transactions.createSigningMessage(
    txnRequest
  )) as AptosAPIResponse<{ message: HexEncodedBytes }>;
  raiseForStatus(200, response, txnRequest);

  const { message } = response.data;
  return message;
}

const FAKE_SIGNATURE: string = HexString.fromUint8Array(
  new Uint8Array(64)
).hex();

/**
 * Submits a transaction with fake signature to the transaction simulation
 * endpoint that takes JSON payload.
 */
export async function simulateTransaction(
  api: AptosAPI,
  accountFrom: Account,
  txnRequest: UserTransactionRequest
): Promise<OnChainTransaction> {
  const transactionSignature: TransactionSignature = {
    type: "ed25519_signature",
    public_key: accountFrom.pubKey.hex(),
    // use invalid signature for simulation
    signature: FAKE_SIGNATURE,
  };

  const request = { signature: transactionSignature, ...txnRequest };
  const response = (await api.transactions.simulateTransaction(
    request
  )) as AptosAPIResponse<OnChainTransaction[]>;
  raiseForStatus(200, response, request);
  const sim = response.data[0];
  if (!sim) {
    throw new Error("No transaction simulation returned");
  }
  return sim;
}
